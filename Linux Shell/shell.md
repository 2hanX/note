###### `-n`参数会给所有的行加上行号

`cat -n test1`

##### 如果只想给有文本的行加上行号，可以用`-b`参数

`cat -b test1`

##### 如果不想让制表符出现，可以用`-T`参数

`cat -T test1`

###### 查看系统上运行的所有进程

`ps -ef` [^1]

| 字符  | 含义                                           |
| ----- | ---------------------------------------------- |
| PID   | 进程的进程ID                                   |
| UID   | 启动这些进程的用户                             |
| PPID  | 父进程的进程号(如果该进程是由另一个进程启动的) |
| C     | 进程生命周期中的CPU利用率                      |
| STIME | 进程启动时的系统时间                           |
| TTY   | 进程启动时的终端设备                           |
| TIME  | 运行进程需要的累积 CPU 时间                    |
| CMD   | 启动的程序名称                                 |

`ps -l`

| 字符  | 含义                                                         |
| ----- | ------------------------------------------------------------ |
| F     | 内核分配给进程的系统标记                                     |
| S     | 进程的状态(O代表正在运行;S代表在休眠;R代表可运行，正等待运行;Z代表僵化，进程已结束但父进程已不存在;T代表停止 |
| PRI   | 进程的优先级(越大的数字代表越低的优先级)                     |
| NI    | 谦让度值用来参与决定优先级                                   |
| ADDR  | 进程的内存地址                                               |
| SZ    | 假如进程被换出，所需交换空间的大致大小                       |
| WCHAN | 进程休眠的内核函数的地址                                     |

###### 显示进程的层级信息,跟踪子进程和父进程

`ps --forest`

###### 实时监测进程

`top`

| 字符  | 含义                              |
| ----- | --------------------------------- |
| VIRT  | 进程占用的虚拟内存总量            |
| RES   | 进程占用的物理内存总量            |
| SHR   | 进程和其他进程共享的内存总量      |
| TIME+ | 自进程启动到目前为止的CPU时间总量 |

###### Linux 进程信号

| 信号 | 名称 | 描述                         |
| ---- | ---- | ---------------------------- |
| 1    | HUP  | 挂起                         |
| 2    | INT  | 中断                         |
| 3    | QUIT | 结束运行                     |
| 9    | KILL | 无条件终止                   |
| 11   | SEGV | 段错误                       |
| 15   | TERM | 尽可能终止                   |
| 17   | STOP | 无条件停止运行，但不终止     |
| 18   | TSTP | 停止或暂停，但继续在后台运行 |
| 19   | CONT | 在STOP或TSTP之后恢复执行     |

###### `-s`参数支持指定其他信号 [^2]

`kill -s HUP 3940`

###### 通过进程名而不是PID来结束进程,`killall`命令也支持通配符

`killall http*`

###### 查看所有已挂载磁盘的使用情况 

`df`

`df -h`  [^3]

###### 显示当前目录下所有的文件、目录和子目录的磁盘使用情况

`du`

`du -h`

###### 按照会话指定的默认语言的排序规则对文本文件中的数据行排序 [^4]

`sort file1`

`sort -h file1` [^5]

`sort -M file2` [^6]

`sort -t ':' -k 3 -n /etc/passwd` [^7]

`cat /etc/passwd|grep -v '^#'|sort -t ':' -k 3 -n`

`du -sh * |sort -nr` [^8]

###### 搜索数据

`grep three file1.txt`

`grep -v t file1` [^9]

`grep -n t file1` [^10]

`grep -c t file1` [^11]

`grep -e t -e f file1` [^12]

`grep [tf] file1` [^13]

###### 压缩数据

`gzip file1`

`gzip file*`

###### 归档数据

`tar -cvf test.tar test/ test2/` [^14]

`tar -tf test.tar` [^15]

`tar -xvf test.tar` [^16]

###### 命令列表和进程列表

`pwd ; ls ; cd /etc; pwd; echo $BASH_SUBSHELL` [^17]

`(pwd) ; (ls) ;(cd /etc) ; pwd; (echo $BASH_SUBSHELL)` [^18]

`(pwd ; ls ; cd /etc; pwd; (echo $BASH_SUBSHELL))`

###### 探索后台模式

`sleep 10` [^19]

`sleep 10&` [^20]

`jobs` [^21]

`jobs -l`

###### 将进程列表置入后台

`(sleep 2;echo $BASH_SUBSHELL;sleep 2)`

`(sleep 2;echo $BASH_SUBSHELL;sleep 2)&`

`(tar -cf Rich.tar /home/rich ; tar -cf My.tar /home/christine)&`

###### 协程 [^22]

`coproc sleep 10` 

`coproc My_job { sleep 10; }` [^23]

`coproc ( sleep 3 )`

###### 外部命令 [^24]

`which ps`

`type -a ps`

`ps -f`

###### 内建命令 [^25]

`type -a cd`

`type -a exit`

`history` [^26]

`cat .bash_history`

`!!`

`history -a` [^27]

`history -n` [^28]

`alias -p` [^29]

`alias ll='ls -la --color=auto'`

###### 查看全局变量

`printenv` 

`env`

`printenv HOME` 

`echo $HOME`

`ls $HOME` [^30]

###### 局部环境变量

`set` [^31]

###### 设置用户定义变量 [^33]

`echo $my_variable`

`my_variable=hello`

`echo $my_variable`

`my_variable='hello world'` [^32]

###### 设置全局环境变量

`export my_variabl` [^34]

###### 删除环境变量

`unset my_variable` [^35]

###### 设置**PATH**环境变量

`echo $PATH`

`PATH=$PATH:/home/eric/scripts` [^36]

`export PATH`  [^37]

###### 定位系统环境变量

- 登录时作为默认登录shell
  - `/etc/profile` [^38]
  - `$HOME/.bash_profile` [^39]
  - `$HOME/.bashrc`
  - `$HOME/.bash_login`
  - `$HOME/.profile`
- 作为非登录shell的交互式shell [^40]
- 作为运行脚本的非交互shell



[ 下一篇](shell1.md)

---



[^1]: `-e`参数指定显示所有运行在系统上的进程;`-f`参数则扩展了输出
[^2]: 默认情况下，`kill`命令会向命令行中列出的全部PID发送一个TERM信号
[^3]: 把输出中 的磁盘空间按照用户易读的形式显示，通常用M来替代兆字节，用G替代吉字节
[^4]: `sort`命令会把数字当做字 符来执行标准的字符排序
[^5]: 把数字识别成数字而不是字符，并且按值排序
[^6]: `-M`参数，`sort`命令就能识别三字符的月份名，并相应地排序
[^7]: `-t `参数来指定字段分隔符，然后用`-k`参数来指定排序的字段
[^8]: `-r`参数将结果按降序输出
[^9]: 反向搜索(输出不匹配该模式的行)，可加`-v`参数
[^10]: 显示匹配模式的行所在的行号
[^11]: 知道有多少行含有匹配的模式
[^12]: 指定多个匹配模式, 这个例子输出了含有字符t或字符f的所有行
[^13]: 在`grep`搜索中使用正则表达式,这个例子是搜索包含t或者f字符
[^14]: `-c `创建新的 tar 归档文件；`-v `在处理文件时显示文件；`-f file `输出结果到文件或设备 file。该示例命令创建了名为test.tar的归档文件，含有test和test2目录内容
[^15]: 列出tar文件test.tar的内容(但并不提取文件); `-t `列出已有tar归档文件的内容
[^16]: `-x` 提取内容;如果tar文件是从一个目录结构创建的，那整个目录结构都会在当前目录下重新创建

[^17]: 命令列表；在一行中指定要依次运行的一系列命令；用分号隔开；可以用括号括起来;`$BASH_SUBSHELL=0`
[^18]: 进程列表；用括号括起来;`$BASH_SUBSHELL=1`
[^19]: `sleep`命令接受一个参数，该参数是你希望进程等待(睡眠)的秒数;命令`sleep 10`会将会话暂停10秒钟，然后返回shell CLI提示符
[^20]: 将命令置入后台模式;在shell CLI提示符返回之前,会出现两条信息。第一条信息是显示在方括号中的后台作业(background job)号。 第二条是后台作业的进程ID
[^21]: 显示出当前运行在后台模式中的所有用户的进程(作业)
[^22]: 协程可以同时做两件事。它在后台生成一个子shell，并在这个子shell中执行命令,并且将命令置入后台模式
[^23]: 使用命令的扩展语法自己设置名字;必须确保在第一个花括号({)和命令名之间有一个空格。还必须保证命令以分号(;)结 尾。另外，分号和闭花括号(})之间也得有一个空格;只有在拥有多个协 程的时候才需要对协程进行命名，因为你得和它们进行通信。否则的话，让`coproc`命令 将其设置成默认的名字COPROC就行了
[^24]: 外部命令，有时候也被称为文件系统命令，是存在于bash shell之外的程序。它们并不是shell 程序的一部分。外部命令程序通常位于`/bin`、`/usr/bin`、`/sbin`或`/usr/sbin`中。当外部命令执行时，会创建出一个子进程。这种操作被称为衍生(forking)。
[^25]: 内建命令不需要使用子进程来执行。它们已经和shell编译成了一 体
[^26]: bash命令的历史记录是先存放在内存中，当shell退出时才被写入到历史文件中
[^27]: 在退出shell会话之前强制将命令历史记录写入`.bash_history`文件
[^28]: 如果你打开了多个终端会话，仍然可以使用`history -a`命令在打开的会话中 向`.bash_history`文件中添加记录。但是对于其他打开的终端会话，历史记录并不会自动更 新。这是因为`.bash_history`文件只有在打开首个终端会话时才会被读取。要想强制重新读 取`.bash_history`文件，更新终端会话的历史记录，可以使用`history -n`命令
[^29]: 查看当前可用的别名
[^30]: 在`echo`命令中，在变量名前加上`$`可不仅仅是要显示变量当前的值。它能够让变量作为命令 行参数
[^31]: `set`命令会显示为某个特定进程设置的所有环境变量，包括局部变量、全局变量以及用户定义变量;它还会按照字母顺序对结果进行排序
[^32]: 给变量赋一个含有空格的字符串值，必须用单引号来界定字符串的首和尾
[^33]: 自己创建的局部变量或是shell脚本，请使用小写字母;系统变量或局部变量使用大写字母;变量名、等号和值之间没有空格，如果在赋值表达式中加上了空格， bash shell就会把值当成一个单独的命令
[^34]: 创建全局环境变量的方法先创建一个局部环境变量，然后再把它导出到全局环境中。变量名前面不需要加$;子shell中能够正确显示出全局环境变量`my_variable`的值。子shell随后改变了这个变量的值。但是这种改变仅在子 shell 中有效，并不会反映到父 shell 中。子shell甚至无法使用export命令改变父shell中全局环境变量的值
[^35]: 在子进程中删除了一个全局环境变量， 这只对子进程有效。该全局环境变量在父进程中依然可用
[^36]: PATH中各个目录之间是用冒号分隔的
[^37]: 如果希望子shell也能找到你的程序的位置，一定要记得把修改后的PATH环境变量导出;对PATH变量的修改只能持续到退出或重启系统,这种效果并不能一直持续
[^38]: `/etc/profile`文件是系统上默认的bash shell的主启动文件。系统上的每个用户登录时都会执行这个启动文件
[^39]: shell会按照按照下列顺序，运行第一个被找到的文件，余下的则被忽略:	`$HOME/.profile`、`$HOME/.bash_login`、`$HOME/.profile`
[^40]: 如果你的bash shell不是登录系统时启动的(比如是在命令行提示符下敲入bash时启动)，那 么你启动的shell叫作交互式shell。交互式shell不会像登录shell一样运行，但它依然提供了命令行 提示符来输入命令。如果bash是作为交互式shell启动的，它就不会访问`/etc/profile`文件，只会检查用户HOME目录 中的`.bashrc`文件

